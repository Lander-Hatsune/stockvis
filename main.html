<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Vis</title>
    <!-- Add any additional CSS or JS libraries here -->
    <script src="d3.min.js"></script>
    <script src="d3-v6-tip.js"></script>
    <script src="d3.layout.cloud.js"></script>
    <link rel="stylesheet" href="d3-tip.css">
    <style>
        /* Add CSS styles here */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        .section {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px solid #ccc;
        }

        #timeline {
            /* Customize styles for timeline section */
        }

        .brush .handle,
        .brush .handle--e {
            fill: steelblue;
            stroke: none;
        }

        #map {
            /* Customize styles for map section */
        }

        #industryBar {
            /* Customize styles for industry bar section */
        }

        #wordcloud {
            /* Customize styles for wordcloud section */
        }
    </style>
</head>

<body>
    <div id="timeline" class="section">
        <!-- Timeline section -->
        <svg width="1920" height="100"></svg>
    </div>
    <div id="map" class="section">
        <!-- Map section -->
        <svg width="800" height="800"></svg>
    </div>
    <div id="industryBar" class="section">
        <!-- IndustryBar section -->
        <svg width="500" height="200"></svg>
    </div>
    <div id="wordcloud" class="section">
        <!-- Wordcloud section -->
        <svg width="500" height="300"></svg>
    </div>

    <script>
        // JavaScript code to create visualizations will go here
        // D3.js will be used to manipulate the DOM and draw the graphs

        // Set the dimensions and margins of the graph
        const margin = { top: 20, right: 20, bottom: 20, left: 50 };

        // Load data
        d3.json("data.json").then(data => {
            console.log("data:", data);


            var timeL, timeR;
            { // draw timeline
                const width = 1920 - margin.left - margin.right,
                    height = 100 - margin.top - margin.bottom;

                const timelineData = data["klines"]["SH000001"];
                console.log(timelineData);

                // Set the ranges
                const x = d3.scaleTime().range([0, width]);
                const y = d3.scaleLinear().range([height, 0]);

                // Parse the timestamp strings into Date objects
                const parseTime = d3.timeParse("%Q");

                // Define the line
                const valueline = d3.line()
                    .x(d => x(d[0]))
                    .y(d => y(d[5]));

                // Scale the range of the data with padding
                x.domain(
                    [d3.min(timelineData, d => parseTime(d[0])),
                    d3.max(timelineData, d => parseTime(d[0]))]
                );
                y.domain([d3.min(timelineData, d => d[5]), d3.max(timelineData, d => d[5])]);

                // Add the valueline path
                const timelineSvg = d3.select("#timeline svg")

                timelineSvg.append("path")
                    .data([timelineData])
                    .attr("class", "line")
                    .attr("d", valueline)
                    .style("fill", "none") // Remove area fill
                    .style("stroke", "steelblue") // Set line color
                    .style("stroke-width", 2); // Set line width

                // Add the X Axis
                timelineSvg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(d3.timeYear))
                    .selectAll("text")
                    .attr("y", 0)
                    .attr("x", 9)
                    .attr("dy", ".35em")
                    .attr("transform", "rotate(45)")
                    .style("text-anchor", "start");

                // Define a brush
                const brush = d3.brushX()
                    .extent([[0, 0], [width, height]])
                    .on("end", brushed);

                // Append the brush to the SVG
                const brushGroup = timelineSvg.append("g")
                    .attr("class", "brush")
                    .call(brush);

                // Function to handle brush events
                function brushed(e) {
                    const selection = e.selection;
                    if (selection) {
                        // Get the selected time range
                        const startTime = x.invert(selection[0]);
                        const endTime = x.invert(selection[1]);

                        // Print selected time range
                        console.log("Selected time range:", startTime, endTime);
                        timeL = startTime, timeR = endTime

                        updateAll(timeL, timeR);
                    } else {
                    }
                }
                updateAll(d3.min(timelineData, d => parseTime(d[0])),
                    d3.max(timelineData, d => parseTime(d[0])));
            }

            function updateAll(timeL, timeR) {
                const filteredKlines = {};
                for (const [key, values] of Object.entries(data.klines)) {
                    filteredKlines[key] = values.filter(d => {
                        const date = d3.timeParse("%Q")(d[0]);
                        return date >= timeL && date <= timeR;
                    });
                }

                // Update the data object with filtered klines
                const filteredData = {
                    ...data,
                    klines: filteredKlines
                };
                console.log(filteredData);

                updateMap(filteredData);
                updateIndustryBar(filteredData);
                updateWordcloud(filteredData);
            }


            function updateMap(data) {
                d3.json("china.json").then(ChinaGeoJson => {
                    // Set dimensions and margins for the map
                    const width = 800 - margin.left - margin.right;
                    const height = 500 - margin.top - margin.bottom;

                    // Create a projection and path generator
                    const projection = d3.geoMercator()
                        .fitSize([width, height], ChinaGeoJson);

                    const path = d3.geoPath().projection(projection);

                    const mapData = Object.entries(data.provinces).map(([fullname, list]) => {
                        value = list.reduce(
                            (acc, item) => {
                                val = data.klines[item].reduce((acc, k) => acc + k[9], 0);
                                return acc + val;
                            },
                            0
                        );
                        value = Math.log(value);
                        return { fullname, value };
                    });
                    console.log("mapData:", mapData);

                    // Create a color scale
                    const color = d3.scaleSequential(d3.interpolatePuBu) // RdYlGn, PiYG
                        .domain([d3.min(mapData, d => d.value), d3.max(mapData, d => d.value)]);

                    // Append the SVG for the map
                    const mapSvg = d3.select("#map svg")
                        .attr("width", width)
                        .attr("height", height);

                    // Clear existing map paths
                    mapSvg.selectAll("path").remove();

                    // Initialize tooltip
                    const tip = d3.tip()
                        .attr('class', 'd3-tip')
                        .html((e, d) => {
                            const province = mapData.find(p => p.fullname === d.properties.fullname);
                            const value = province ? province.value : "No data";
                            return `<strong>Province:</strong> <span>${d.properties.fullname}</span><br>
                    <strong>Value:</strong> <span>${value}</span>`;
                        });

                    mapSvg.call(tip);

                    // Draw the map
                    mapSvg.selectAll("path")
                        .data(ChinaGeoJson.features)
                        .enter().append("path")
                        .attr("d", path)
                        .attr("fill", d => {
                            const province = mapData.find(p => p.fullname === d.properties.fullname);
                            return province ? color(province.value) : "#ccc";
                        })
                        .attr("stroke", "#333")
                        .attr("stroke-width", 0.5)
                        .on('mouseover', function (e, d) {
                            const element = d3.select(this);
                            element.style("opacity", 0.5);
                            tip.show(e, d);
                        })
                        .on("mousemove", function (e, d) {
                            const tipNode = document.querySelector('.d3-tip');
                            tipNode.style.left = (e.pageX - tipNode.clientWidth / 2) + 'px';
                            tipNode.style.top = (e.pageY - tipNode.offsetHeight - 15) + 'px';
                        })
                        .on('mouseout', function (e, d) {
                            const element = d3.select(this);
                            element.style("opacity", 1)
                            tip.hide(e, d);
                        });


                    // Clear existing legend
                    mapSvg.selectAll(".legend").remove();

                    // Add a vertical legend using discrete steps
                    const legendHeight = 300;
                    const legendWidth = 20;
                    const steps = 50; // Number of steps for the legend
                    const stepHeight = legendHeight / steps;

                    const legendSvg = mapSvg.append("g")
                        .attr("class", "legend")
                        .attr("transform", `translate(${width - legendWidth - 20}, ${height - legendHeight - 10})`);

                    // Create a color legend with discrete steps
                    const legendScale = d3.scaleLinear()
                        .domain([d3.min(mapData, d => d.value), d3.max(mapData, d => d.value)])
                        .range([legendHeight, 0]);

                    d3.range(steps).forEach(i => {
                        const value = legendScale.invert(i * stepHeight);
                        legendSvg.append("rect")
                            .attr("x", 0)
                            .attr("y", i * stepHeight)
                            .attr("width", legendWidth)
                            .attr("height", stepHeight)
                            .attr("fill", color(value));
                    });

                    const legendAxis = d3.axisRight(legendScale)
                        .ticks(10);

                    legendSvg.append("g")
                        .attr("transform", `translate(${legendWidth}, 0)`)
                        .call(legendAxis);
                });
            }

            function updateIndustryBar(data) {
                // Set dimensions for the IndustryBar section
                const width = 1800;
                const height = 200;

                const industryData = Object.entries(data.industries).map(([name, list]) => {
                    value = list.reduce((acc, item) => {
                        val = data.klines[item].reduce((acc, k) => acc + k[9], 0);
                        return acc + val;
                    }, 0);
                    rate = list.reduce((acc, item) => {
                        val = data.klines[item].at(-1)[2] - data.klines[item][0][2];
                        return acc + val;
                    }, 0);
                    value = value / 100000000;
                    return { name, value, rate };
                }).sort((a, b) => b.value - a.value).slice(0, 30);
                console.log("industryData:", industryData);

                // Create scales for the x and y axes
                const x = d3.scaleBand()
                    .range([0, width])
                    .padding(0.1)
                    .domain(industryData.map(d => d.name));

                const y = d3.scaleLinear()
                    .range([height, 0])
                    .domain([0, d3.max(industryData, d => d.value)]);

                // Append SVG for the IndustryBar section
                const industryBarSvg = d3.select("#industryBar svg")
                    .attr("width", width + margin.left + margin.right)
                    .attr("height", height + margin.top + margin.bottom)
                    .append("g")
                    .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

                // Initialize tooltip
                const tip = d3.tip()
                    .attr('class', 'd3-tip')
                    .html((e, d) => {
                        return `<strong>Industry:</strong> <span>${d.name}</span><br>
                    <strong>Value:</strong> <span>${d.value}</span>`;
                    });

                industryBarSvg.call(tip);

                const color = d3.scaleSequential(d3.interpolateRdYlGn) // RdYlGn, PiYG
                    .domain([d3.min(industryData, d => d.rate), d3.max(industryData, d => d.rate)]);

                // Draw bars
                industryBarSvg.selectAll(".bar")
                    .data(industryData)
                    .enter().append("rect")
                    .attr("class", "bar")
                    .attr("x", d => x(d.name))
                    .attr("width", x.bandwidth())
                    .attr("y", d => y(d.value))
                    .attr("height", d => height - y(d.value))
                    .attr("fill", d => color(d.rate))
                    .on('mouseover', function (e, d) {
                        const element = d3.select(this);
                        element.style("opacity", 0.5);
                        tip.show(e, d);
                    })
                    .on("mousemove", function (e, d) {
                        const tipNode = document.querySelector('.d3-tip');
                        tipNode.style.left = (e.pageX - tipNode.clientWidth / 2) + 'px';
                        tipNode.style.top = (e.pageY - tipNode.offsetHeight - 15) + 'px';
                    })
                    .on('mouseout', function (e, d) {
                        const element = d3.select(this);
                        element.style("opacity", 1)
                        tip.hide(e, d);
                    });

                // Add the x Axis
                industryBarSvg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x));

                // Add the y Axis
                industryBarSvg.append("g")
                    .call(d3.axisLeft(y));
            }

            function updateWordcloud(data) {
                const width = 500;
                const height = 500;

                const wordDict = {};
                Object.entries(data.companies).forEach(([symbol, comp]) => {
                    amount = data.klines[symbol].reduce((acc, k) => acc + k[9], 0);
                    comp.words.forEach(word => {
                        if (wordDict[word]) {
                            wordDict[word].amount += amount;
                            wordDict[word].count += 1;
                        } else {
                            wordDict[word] = {
                                amount: amount,
                                count: 1,
                            }
                        }
                    })
                });

                let wordData = Object.entries(wordDict).map(([word, vals]) => {
                    return {
                        text: word,
                        size: vals.count / 100,
                        value: vals.amount,
                    };
                }).sort((a, b) => b.size - a.size).slice(0, 50);
                console.log("wordData:", wordData);

                const colorScale = d3.scaleSequential(d3.interpolateBlues)
                    .domain([d3.min(wordData, d => d.value), d3.max(wordData, d => d.value)]); // Assuming values are in range [0, 1]

                const layout = d3.layout.cloud()
                    .size([width, height])
                    .words(wordData)
                    .padding(5)
                    .rotate(0)
                    .font("Impact")
                    .fontSize(d => d.size)
                    .on("end", draw);

                layout.start();

                function draw(words) {
                    const wordcloudSvg = d3.select("#wordcloud svg")
                        .attr("width", width)
                        .attr("height", height)
                        .append("g")
                        .attr("transform", "translate(" + width / 2 + "," + height / 2 + ")");

                    wordcloudSvg.selectAll("text")
                        .data(words)
                        .enter().append("text")
                        .style("font-size", d => d.size + "px")
                        .style("font-family", "Impact")
                        .style("fill", d => colorScale(d.value))
                        .attr("text-anchor", "middle")
                        .attr("transform", d => "translate(" + [d.x, d.y] + ")rotate(" + d.rotate + ")")
                        .text(d => d.text);
                }
            }
        });

    </script>
</body>

</html>