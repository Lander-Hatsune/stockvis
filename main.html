<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Stock Vis</title>
    <!-- Add any additional CSS or JS libraries here -->
    <script src="d3.min.js"></script>
    <script src="d3-v6-tip.js"></script>
    <link rel="stylesheet" href="d3-tip.css">
    <style>
        /* Add CSS styles here */
        body {
            font-family: Arial, sans-serif;
            margin: 0;
            padding: 0;
        }

        .section {
            margin-bottom: 20px;
            padding: 20px;
            border: 1px solid #ccc;
        }

        #timeline {
            /* Customize styles for timeline section */
        }

        .brush .handle,
        .brush .handle--e {
            fill: steelblue;
            stroke: none;
        }

        #map {
            /* Customize styles for map section */
        }

        #industryBar {
            /* Customize styles for industry bar section */
        }

        #wordcloud {
            /* Customize styles for wordcloud section */
        }
    </style>
</head>

<body>
    <div id="timeline" class="section">
        <!-- Timeline section -->
        <svg width="1920" height="100"></svg>
    </div>
    <div id="map" class="section">
        <!-- Map section -->
        <svg width="800" height="800"></svg>
    </div>
    <div id="industryBar" class="section">
        <!-- IndustryBar section -->
        <svg width="500" height="200"></svg>
    </div>
    <div id="wordcloud" class="section">
        <!-- Wordcloud section -->
        <svg width="500" height="300"></svg>
    </div>

    <script>
        // JavaScript code to create visualizations will go here
        // D3.js will be used to manipulate the DOM and draw the graphs

        // Set the dimensions and margins of the graph
        const margin = { top: 20, right: 20, bottom: 20, left: 50 };

        // Timeline placeholder
        const timelineSvg = d3.select("#timeline svg");
        timelineSvg.append("g")
            .attr("transform", "translate(" + margin.left + "," + margin.top + ")");

        // Map placeholder
        const mapSvg = d3.select("#map svg");
        mapSvg;

        // IndustryBar placeholder
        const industryBarSvg = d3.select("#industryBar svg");
        industryBarSvg.append("text")
            .attr("x", 250)
            .attr("y", 100)
            .text("IndustryBar Placeholder")
            .attr("text-anchor", "middle")
            .style("font-size", "20px");

        // Wordcloud placeholder
        const wordcloudSvg = d3.select("#wordcloud svg");
        wordcloudSvg.append("text")
            .attr("x", 250)
            .attr("y", 150)
            .text("Wordcloud Placeholder")
            .attr("text-anchor", "middle")
            .style("font-size", "20px");

        // Load data
        d3.json("data.json").then(data => {
            console.log("data:", data);


            var timeL, timeR;
            { // draw timeline
                const width = 1920 - margin.left - margin.right,
                    height = 100 - margin.top - margin.bottom;

                const timelineData = data["klines"]["SH000001"];
                console.log(timelineData);

                // Set the ranges
                const x = d3.scaleTime().range([0, width]);
                const y = d3.scaleLinear().range([height, 0]);

                // Parse the timestamp strings into Date objects
                const parseTime = d3.timeParse("%Q");

                // Define the line
                const valueline = d3.line()
                    .x(d => x(d[0]))
                    .y(d => y(d[5]));

                // Scale the range of the data with padding
                x.domain(
                    [d3.min(timelineData, d => parseTime(d[0])),
                    d3.max(timelineData, d => parseTime(d[0]))]
                );
                y.domain([d3.min(timelineData, d => d[5]), d3.max(timelineData, d => d[5])]);

                // Add the valueline path
                timelineSvg.append("path")
                    .data([timelineData])
                    .attr("class", "line")
                    .attr("d", valueline)
                    .style("fill", "none") // Remove area fill
                    .style("stroke", "steelblue") // Set line color
                    .style("stroke-width", 2); // Set line width

                // Add the X Axis
                timelineSvg.append("g")
                    .attr("transform", "translate(0," + height + ")")
                    .call(d3.axisBottom(x).ticks(d3.timeYear))
                    .selectAll("text")
                    .attr("y", 0)
                    .attr("x", 9)
                    .attr("dy", ".35em")
                    .attr("transform", "rotate(45)")
                    .style("text-anchor", "start");

                // Define a brush
                const brush = d3.brushX()
                    .extent([[0, 0], [width, height]])
                    .on("start brush end", brushed);

                // Append the brush to the SVG
                const brushGroup = timelineSvg.append("g")
                    .attr("class", "brush")
                    .call(brush);

                // Function to handle brush events
                function brushed(e) {
                    const selection = e.selection;
                    if (selection) {
                        // Get the selected time range
                        const startTime = x.invert(selection[0]);
                        const endTime = x.invert(selection[1]);

                        // Print selected time range
                        console.log("Selected time range:", startTime, endTime);
                        timeL = startTime, timeR = endTime
                    } else {
                    }
                }
            }

            {// draw Map
                d3.json("china.json").then(ChinaGeoJson => {
                    // Set dimensions and margins for the map
                    const width = 800;
                    const height = 500;

                    // Create a projection and path generator
                    const projection = d3.geoMercator()
                        .fitSize([width, height], ChinaGeoJson);

                    const path = d3.geoPath().projection(projection);

                    const mapData = Object.entries(data.provinces).map(([fullname, list]) => {
                        value = list.reduce(
                            (acc, item) => {
                                val = data.klines[item].reduce((acc, k) => acc + k[1], 0);
                                return acc + val;
                            },
                            0
                        );
                        value = Math.log(value);
                        return { fullname, value };
                    })

                    // Create a color scale
                    const color = d3.scaleSequential(d3.interpolatePuBu) // RdYlGn, PiYG
                        .domain([d3.min(mapData, d => d.value), d3.max(mapData, d => d.value)]);

                    // Append the SVG for the map
                    const mapSvg = d3.select("#map svg")
                        .attr("width", width)
                        .attr("height", height);

                    // Initialize tooltip
                    const tip = d3.tip()
                        .attr('class', 'd3-tip')
                        .html((e, d) => {
                            const province = mapData.find(p => p.fullname === d.properties.fullname);
                            const value = province ? province.value : "No data";
                            return `<strong>Province:</strong> <span>${d.properties.fullname}</span><br>
                    <strong>Value:</strong> <span>${value}</span>`;
                        });

                    mapSvg.call(tip);

                    // Draw the map
                    mapSvg.selectAll("path")
                        .data(ChinaGeoJson.features)
                        .enter().append("path")
                        .attr("d", path)
                        .attr("fill", d => {
                            const province = mapData.find(p => p.fullname === d.properties.fullname);
                            return province ? color(province.value) : "#ccc";
                        })
                        .attr("stroke", "#333")
                        .attr("stroke-width", 0.5)
                        .on('mouseover', function (e, d) {
                            const element = d3.select(this);
                            element.style("opacity", 0.5);
                            tip.show(e, d);
                        })
                        .on("mousemove", function (e, d) {
                            const tipNode = document.querySelector('.d3-tip');
                            tipNode.style.left = (e.pageX - tipNode.clientWidth / 2) + 'px';
                            tipNode.style.top = (e.pageY - tipNode.offsetHeight - 15) + 'px';
                        })
                        .on('mouseout', function (e, d) {
                            const element = d3.select(this);
                            element.style("opacity", 1)
                            tip.hide(e, d);
                        });

                    // Add a vertical legend using discrete steps
                    const legendHeight = 300;
                    const legendWidth = 20;
                    const steps = 50; // Number of steps for the legend
                    const stepHeight = legendHeight / steps;

                    const legendSvg = mapSvg.append("g")
                        .attr("transform", `translate(${width - legendWidth - 20}, ${height - legendHeight - 10})`);

                    // Create a color legend with discrete steps
                    const legendScale = d3.scaleLinear()
                        .domain([d3.min(mapData, d => d.value), d3.max(mapData, d => d.value)])
                        .range([legendHeight, 0]);

                    d3.range(steps).forEach(i => {
                        const value = legendScale.invert(i * stepHeight);
                        legendSvg.append("rect")
                            .attr("x", 0)
                            .attr("y", i * stepHeight)
                            .attr("width", legendWidth)
                            .attr("height", stepHeight)
                            .attr("fill", color(value));
                    });

                    const legendAxis = d3.axisRight(legendScale)
                        .ticks(10);

                    legendSvg.append("g")
                        .attr("transform", `translate(${legendWidth}, 0)`)
                        .call(legendAxis);
                });
            }
        });

    </script>
</body>

</html>